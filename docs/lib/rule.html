<!DOCTYPE html><html lang="en"><head><title>lib/rule</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="lib/rule"><meta name="groc-project-path" content="lib/rule.js"><meta name="groc-github-url" content="https://github.com/dglmoore/gomen"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/dglmoore/gomen/blob/master/lib/rule.js">lib/rule.js</a></div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="rules">Rules</h1>
<p>Agents need a rule according to which they will change their strategies
based on the difference in their counterfactual payoffs from previous
rounds. Essentially, the rules are probability distributions over the
real-valued payoff differences.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><em><strong><code>sigmoid(beta=1.0)</code></strong></em></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>sigmoid</code> rule specifies that an agent should change its strategy with
probability</p>
<pre><code>P(dp) = 1 / (1 + e^(-beta*dp))</code></pre>
<p>by returing a function which implements the above operation.
The following errors are thrown at the time of calling <code>sigmoid</code>:</p>
<ul>
<li>a <code>TypeError</code> if <code>beta</code> is not a `Number</li>
<li>a <code>RangeError</code> if <code>beta &lt; 0.0</code></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> sigmoid = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">beta=1.0</span>) </span>{
    <span class="hljs-keyword">if</span> (beta.constructor.name !== <span class="hljs-string">'Number'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'sigmoid expects beta to be a number'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beta &lt; <span class="hljs-number">0.0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">`sigmoid expects beta &gt; 0, got <span class="hljs-subst">${beta}</span>`</span>);
    }

    <span class="hljs-keyword">return</span> (dp) =&gt; <span class="hljs-number">1.0</span> / (<span class="hljs-number">1.0</span> + <span class="hljs-built_in">Math</span>.exp(-beta*dp));
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><em><strong><code>fermi(beta=1.0) = sigmoid(beta=1.0)</code></strong></em></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>fermi</code> rule is essentially an alias for the <code>sigmoid</code> rule.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> fermi = sigmoid;</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p><em><strong><code>heaviside(epsilon=1e-3)</code></strong></em></p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>The <code>heaviside</code> rule specifies that an agent should change its strategy
with probability</p>
<pre><code>P(dp) = (|dp| &lt; epsilon) ? 0.5 : (dp &lt; 0) ? 0.0 : 1.0,</code></pre>
<p>i.e. according to a step function. Here <code>epsilon</code> represents the size
of the region around <code>dp = 0</code> in which the probability is <code>0.5</code> to
account for floating-point precision errors.
The following errors are thrown at the time of calling <code>sigmoid</code>:</p>
<ul>
<li>a <code>TypeError</code> if <code>epsilon</code> is not a `Number</li>
<li>a <code>RangeError</code> if <code>epsilon &lt; 0.0</code></li>
</ul></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">const</span> heaviside = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">epsilon=1e-3</span>) </span>{
    <span class="hljs-keyword">if</span> (epsilon.constructor.name !== <span class="hljs-string">'Number'</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'heaviside expects epsilon to be a number'</span>);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (epsilon &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">`heaviside expects epsilon &gt; 0, got <span class="hljs-subst">${epsilon}</span>`</span>);
    }

    <span class="hljs-keyword">return</span> (dp) =&gt; {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(dp) &lt; epsilon) {
            <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>(dp &gt; <span class="hljs-number">0</span>);
        }
    };
};</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><hr></div></div><div class="code"><div class="wrapper"><span class="hljs-built_in">module</span>.exports = { sigmoid, fermi, heaviside };</div></div></div></div></body></html>